#!groovyâ€‹

properties([[$class: 'BuildDiscarderProperty', strategy: [$class: 'LogRotator', numToKeepStr: '10']]])

def skipCi = false

agent { label 'mesos' }

stage('build & unit tests & nexus & sonar') {

    node {
        checkout scm
        result = sh (script: "git log -1 | grep 'updating poms for'", returnStatus: true)
        skipCi = result != 0 ? build() : true
    }
}

if (skipCi) {
    echo "ci-skip step reached!. Mark job to be finished successfully..."
    currentBuild.result = 'SUCCESS'
    return
}

def branchType = getBranchType "${env.BRANCH_NAME}"
def branchDeploymentEnvironment = getBranchDeploymentEnvironment branchType

if (branchDeploymentEnvironment) {

    stage('build docker image') {

        node {
            mvn "clean package docker:build -DpushImage -DskipTests"
        }
    }

    stage('deploy artifact to DC/OS') {

        if (branchDeploymentEnvironment == "prod") {

            timeout(time: 1, unit: 'DAYS') {
                input "Do you want to deploy to production?"
            }
        }

        node {
            deployArtifact branchDeploymentEnvironment
        }
    }

    if (branchDeploymentEnvironment != "prod") {


        stage('perform tests') {

            node {
                executeTests branchDeploymentEnvironment
            }
        }
    }


    if (branchType == "dev") {

        stage('start release') {

            timeout(time: 1, unit: 'HOURS') {
                input "Do you want to prepare a release process?"
            }
            node {
                mvn("jgitflow:release-start")
            }
        }
    }

    else if (branchType == "release") {

        branchDeploymentEnvironment = "uat"

        stage('deploy release candidate to UAT') {

            timeout(time: 1, unit: 'HOURS') {
                input 'Do you want to execute a release process? If so, after deployment and integration tests successfully passed against ${branch_deployment_environment}, release will be created...'
            }
            node {
                deployArtifact branchDeploymentEnvironment
            }
        }

        stage('perform acceptation tests') {

            node {
                executeTests branchDeploymentEnvironment
            }
        }

        stage('end release') {

            node {
                mvn("jgitflow:release-finish -Dmaven.javadoc.skip=true -DnoDeploy=true")
            }
        }
    }

    else if (branchType == "hotfix") {

        stage('finish hotfix') {

            timeout(time: 1, unit: 'HOURS') {
                input "Is the hotfix finished?"
            }
            node {
                mvn("jgitflow:hotfix-finish -Dmaven.javadoc.skip=true -DnoDeploy=true")
            }
        }
    }
}



def getBranchType(String branchName) {

    def devPattern = ".*develop"
    def releasePattern = ".*release/.*"
    def featurePattern = ".*feature/.*"
    def hotfixPattern = ".*hotfix/.*"
    def masterPattern = ".*master"

    if (branchName =~ devPattern) {
        return "dev"
    } else if (branchName =~ releasePattern) {
        return "release"
    } else if (branchName =~ masterPattern) {
        return "master"
    } else if (branchName =~ featurePattern) {
        return "feature"
    } else if (branchName =~ hotfixPattern) {
        return "hotfix"
    } else {
        return null
    }
}

def getBranchDeploymentEnvironment(String branchType) {

    if (branchType == "dev") {
        return "dev"
    } else if (branchType == "release") {
        return "syt"
    } else if (branchType == "master") {
        return "prod"
    } else {
        return null
    }
}

def mvn(String goals) {
    def mvnHome = tool "Maven-3.3.9"
    def javaHome = tool "JDK1.8.0_102"

    withCredentials([usernamePassword(credentialsId: 'githubuser', usernameVariable: 'GIT_USER', passwordVariable: 'GIT_PASSWORD'),
                     string(credentialsId: 'nexusReleasesUrl', variable: 'NEXUS_RELEASES_URL'),
                     string(credentialsId: 'nexusSnapshotsUrl', variable: 'NEXUS_SNAPSHOTS_URL'),
                     usernamePassword(credentialsId: 'nexus', usernameVariable: 'NEXUS_USER', passwordVariable: 'NEXUS_PASSWORD'),
                     string(credentialsId: 'sonarUrl', variable: 'SONAR_URL')]) {

        withEnv(["JAVA_HOME=${javaHome}", "PATH+MAVEN=${mvnHome}/bin"]) {
            sh "mvn -B ${goals}"
        }
    }
}

def version() {
    def matcher = readFile('pom.xml') =~ '<version>(.+)</version>'
    return matcher ? matcher[0][1] : null
}

def artifactId() {
    def matcher = readFile('pom.xml') =~ '<artifactId>(.+)</artifactId>'
    return matcher ? matcher[0][1] : null
}

def build() {
    def v = version()
    currentBuild.displayName = "${env.BRANCH_NAME}-${v}-${env.BUILD_NUMBER}"
    mvn "clean deploy -DskipITs=true -DskipPTs=true sonar:sonar --settings /opt/settings.xml"
    return false
}


def executeTests(String branchDeploymentEnvironment) {

    switch (branchDeploymentEnvironment) {

        case "dev":
            //TODO: Check which tests should be performed here!
            break
        case "syt":
            //Executing performance tests...
            //TODO: Pass maven arguments with URL and port of running service (instead of localhost:8080) to be used in performance tests
            mvn "clean verify -DskipUTs=true -DskipITs=true -Dremote.service.pt.host=localhost -Dremote.service.pt.port=8080"
            break
        case "uat":
            //Executing integration tests...
            //TODO: Pass environment variable with URL of running service (instead of localhost:8080) to be used in integration tests
            mvn "clean verify -DskipUTs=true -DskipPTs=true -Dremote.service.it.url=http://localhost:8080"
            break
        default:
            break
    }
}

def deployArtifact(String branchDeploymentEnvironment) {

    withCredentials([usernamePassword(credentialsId: 'jenkinsDcos_' + branchDeploymentEnvironment, usernameVariable: 'USER_ID', passwordVariable: 'USER_PASSWORD'),
                     string(credentialsId: 'dcosLoginUrl_' + branchDeploymentEnvironment, variable: 'DCOS_LOGIN_URL'),
                     string(credentialsId: 'marathonApiUrl_'+ branchDeploymentEnvironment, variable: 'MARATHON_API_URL')]) {


        def artifactId = artifactId()

        withEnv(["ARTIFACT_ID=${artifactId}"]) {
            sh "echo Deploying to ${branchDeploymentEnvironment}"
            //TODO: Return URL:PORT of running service! Put it in an environment variable to be used at testing phase
            sh "/opt/dcos_deploy.sh"
        }
    }
}
